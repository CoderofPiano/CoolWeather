synchronized锁住的是括号里的对象，而不是代码

一，synchronized同方法：
1,public synchronized void test()
非静态方法锁的是方法的所在类的某个对象，其他线程中调用当前对象的该synchronized以及其他synchronized的处于等待;
其他线程中调用当前对象的其他非synchronized方法正常运行;
其他线程中调用当前类的其他实例对象的所有方法正常运行，不受影响;

2public static synchronized void test()
如果一个类中定义了一个synchronized 的 static 函数A，也定义了一个 synchronized 的 instance函数B，那么这个类的同一对象Obj在多线程中分别访问A和B两个方法时，不会构成同步，因为它们的锁都不一样。B方法的锁是Obj这个对象，而B的锁是Obj所属的那个Class。


二，synchronized同步块：
1，同步到单一对象锁：
当使用同步块时，如果方法下的同步块都同步到一个对象上的锁，则所有的任务（线程）只能互斥的进入这些同步块。
Resource1.java演示了三个线程（包括main线程）试图进入某个类的三个不同的方法的同步块中，虽然这些同步块处在不同的方法中，但由于是同步到同一个对象（当前对象 synchronized (this)），所以对它们的方法依然是互斥的。

2,同步到多个对象锁
Resource1.java演示了三个线程（包括main线程）试图进入某个类的三个不同的方法的同步块中，这些同步块处在不同的方法中，并且是同步到三个不同的对象（synchronized (this)，synchronized(syncObject1)，synchronized (syncObject2)），所以对它们的方法中的临界资源访问是独立的。
