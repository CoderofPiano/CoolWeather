一、UiccCardApplication的初始化过程
在上一章时可以知道UiccCardApplication是在UiccCard.update(）里创建或更新的，但要注意其是一个数组：

    private UiccCardApplication[] mUiccApplications =
            new UiccCardApplication[IccCardStatus.CARD_MAX_APPS];

    public void update(Context c, CommandsInterface ci, IccCardStatus ics) {

            //update applications
            if (DBG) log(ics.mApplications.length + " applications");
            for ( int i = 0; i < mUiccApplications.length; i++) {
                if (mUiccApplications[i] == null) {
                    //Create newly added Applications
                    if (i < ics.mApplications.length) {
                        mUiccApplications[i] = new UiccCardApplication(this,
                                ics.mApplications[i], mContext, mCi);
                    }
                } else if (i >= ics.mApplications.length) {
                    //Delete removed applications
                    mUiccApplications[i].dispose();
                    mUiccApplications[i] = null;
                } else {
                    //Update the rest
                    mUiccApplications[i].update(ics.mApplications[i], mContext, mCi);
                }
            }
  }

UiccCardApplication是一个普通java类
    public class UiccCardApplication {}

    public UiccCardApplication(UiccCard uiccCard,
                        IccCardApplicationStatus as,
                        Context c,
                        CommandsInterface ci) {
        if (DBG) log("Creating UiccApp: " + as);
        mUiccCard = uiccCard;
        mAppState = as.app_state;
        mAppType = as.app_type;
        mAuthContext = getAuthContext(mAppType);
        mPersoSubState = as.perso_substate;
        mAid = as.aid;
        mAppLabel = as.app_label;
        mPin1Replaced = (as.pin1_replaced != 0);
        mPin1State = as.pin1;
        mPin2State = as.pin2;

        mContext = c;
        mCi = ci;
	
 	 //创建IccFileHandler对象 
        mIccFh = createIccFileHandler(as.app_type);
	 //创建IccRecords对象  
        mIccRecords = createIccRecords(as.app_type, mContext, mCi);
        if (mAppState == AppState.APPSTATE_READY) {
            queryFdn();
            queryPin1State();
        }
        mCi.registerForNotAvailable(mHandler, EVENT_RADIO_UNAVAILABLE, null);
    }
 在构造函数中主要完成了四个任务：
   1、创建SIM卡的文件系统管理者IccFileHandler的子类对象：SIMFileHandler/RuimFileHandler/UsimFileHandler/CsimFileHandler/IsimFileHandler
   2、创建SIM卡信息IccRecords的子类对象：SIMRecords/RuimRecords/IsimUiccRecords
   3、查询Fdn号码
   4、查询Pin码状态

二、UiccCardApplication的主要功能

public IccFileHandler getIccFileHandler() {}  
public IccRecords getIccRecords() {}  
public void supplyPin (String pin, Message onComplete) {}  
public void supplyPuk (String puk, String newPin, Message onComplete) {}  
public void supplyPin2 (String pin2, Message onComplete) {}  
public void supplyPuk2 (String puk2, String newPin2, Message onComplete) {}  
public void supplyNetworkDepersonalization (String pin, Message onComplete) {}  
public boolean getIccLockEnabled() {}  
public boolean getIccFdnEnabled() {}  
public void setIccLockEnabled (boolean enabled, String password, Message onComplete) {}  
public void setIccFdnEnabled (boolean enabled, String password, Message onComplete) {}  
public void changeIccLockPassword(String oldPassword, String newPassword, Message onComplete) {}  
public void changeIccFdnPassword(String oldPassword, String newPassword, Message onComplete) {} 

由此可以看到UiccCardApplication的主要功能：
   1、创建并向外提供IccFileHandler、IccRecords对象
   2、查询、设置Fdn的状态
   3、查询、设置Pin、Puk状态和密码
   4、提供网络锁、Pin锁、状态OK的监听器
这些功能主要是在Setting下面的Call Setting或SIM Manager中来使用，其最终会通过RIL实例来向下设置然后返回结果，例如：
    /**
     * Change the ICC password used in ICC pin lock
     * When the operation is complete, onComplete will be sent to its handler
     *
     * @param oldPassword is the old password
     * @param newPassword is the new password
     * @param onComplete
     *        onComplete.obj will be an AsyncResult
     *        onComplete.arg1 = attempts remaining or -1 if unknown
     *        ((AsyncResult)onComplete.obj).exception == null on success
     *        ((AsyncResult)onComplete.obj).exception != null on fail
     */
    public void changeIccLockPassword(String oldPassword, String newPassword,
            Message onComplete) {
        synchronized (mLock) {
            if (DBG) log("changeIccLockPassword");
            mCi.changeIccPinForApp(oldPassword, newPassword, mAid,
                    mHandler.obtainMessage(EVENT_CHANGE_PIN1_DONE, onComplete));
        }
    }


三、UiccCardApplication的更新过程
前面说过了，当SIM卡或者Radio状态改变时，就会通过UiccController更新UiccCard，然后再由UiccCard更新UiccCardApplication，此时就会调用update()方法： 
    public void update (IccCardApplicationStatus as, Context c, CommandsInterface ci) {
        synchronized (mLock) {
            if (mDestroyed) {
                loge("Application updated after destroyed! Fix me!");
                return;
            }

            if (DBG) log(mAppType + " update. New " + as);
            mContext = c;
            mCi = ci;
            AppType oldAppType = mAppType;
            AppState oldAppState = mAppState;
            PersoSubState oldPersoSubState = mPersoSubState;
            mAppType = as.app_type;
            mAuthContext = getAuthContext(mAppType);
            mAppState = as.app_state;
            mPersoSubState = as.perso_substate;
            mAid = as.aid;
            mAppLabel = as.app_label;
            mPin1Replaced = (as.pin1_replaced != 0);
            mPin1State = as.pin1;
            mPin2State = as.pin2;

            if (mAppType != oldAppType) {
                //重新创建IccFileHandler和IccRecords  
                if (mIccFh != null) { mIccFh.dispose();}
                if (mIccRecords != null) { mIccRecords.dispose();}
                mIccFh = createIccFileHandler(as.app_type);
                mIccRecords = createIccRecords(as.app_type, c, ci);
            }

            if (mPersoSubState != oldPersoSubState &&
                    mPersoSubState == PersoSubState.PERSOSUBSTATE_SIM_NETWORK) {
		//通知网络锁的监听器	
                notifyNetworkLockedRegistrantsIfNeeded(null);
            }

            if (mAppState != oldAppState) {
                if (DBG) log(oldAppType + " changed state: " + oldAppState + " -> " + mAppState);
                // If the app state turns to APPSTATE_READY, then query FDN status,
                //as it might have failed in earlier attempt.
                if (mAppState == AppState.APPSTATE_READY) {
		//重新查询Fdn和Pin
                    queryFdn();
                    queryPin1State();
                }
		//通知网络锁和网络注册的监听器  
                notifyPinLockedRegistrantsIfNeeded(null);
                notifyReadyRegistrantsIfNeeded(null);
            }
        }
    }

  这里没什么可说的，个构造方法中内容大致一样，另外多了动画i监听器的内容：
        1、更新当前状态相关的成员变量
        2、需要时重新构建IccFileHandler、IccRecords，以及重新查询Fdn和Pin
        3、通知监听器
